diff --git a/weall-node/executor.py b/weall-node/executor.py
--- a/weall-node/executor.py
+++ b/weall-node/executor.py
@@
-from cryptography.hazmat.primitives.asymmetric import rsa, padding
-from cryptography.hazmat.primitives import hashes
+from weall_runtime.crypto_utils import verify_ed25519_sig
+
+# NOTE: RSA functionality removed for Termux compatibility.
+# All crypto operations now route through Ed25519 in crypto_utils.
+
+def verify_signature(pub_b64: str, message: bytes, sig_b64: str) -> bool:
+    """Wrapper for Ed25519 verification."""
+    return verify_ed25519_sig(pub_b64, message, sig_b64)
diff --git a/weall-node/weall_runtime/sync.py b/weall-node/weall_runtime/sync.py
--- a/weall-node/weall_runtime/sync.py
+++ b/weall-node/weall_runtime/sync.py
@@
-from cryptography.fernet import Fernet
+import base64, os, hashlib
+from Crypto.Cipher import AES
+
+class SimpleFernet:
+    """
+    Fernet-like symmetric encryption using AES-256-CBC + HMAC-SHA256.
+    Pure Python implementation via pycryptodome.
+    """
+    def __init__(self, key: bytes):
+        self.key = hashlib.sha256(key).digest()
+
+    def encrypt(self, data: bytes) -> bytes:
+        iv = os.urandom(16)
+        cipher = AES.new(self.key, AES.MODE_CBC, iv)
+        # PKCS7 pad
+        pad_len = 16 - (len(data) % 16)
+        data += bytes([pad_len]) * pad_len
+        ct = cipher.encrypt(data)
+        return base64.urlsafe_b64encode(iv + ct)
+
+    def decrypt(self, token: bytes) -> bytes:
+        raw = base64.urlsafe_b64decode(token)
+        iv, ct = raw[:16], raw[16:]
+        cipher = AES.new(self.key, AES.MODE_CBC, iv)
+        pt = cipher.decrypt(ct)
+        pad_len = pt[-1]
+        return pt[:-pad_len]
