*** /dev/null
--- a/weall_node/executor_globals.py
@@
+# Centralized knobs for governance & reputation logic
+GLOBAL_PARAMS = {
+    "quorum": 3,
+    "threshold": 0.5,
+    "juror_reward": 2,
+    "juror_slash": 1,
+    "author_slash": 5,
+    "profile_slash": 10,
+}
+
+# Default PoH requirements
+POH_REQUIREMENTS = {
+    "propose": 3,
+    "vote": 2,
+    "post": 2,
+    "comment": 2,
+    "edit_post": 2,
+    "delete_post": 2,
+    "edit_comment": 2,
+    "delete_comment": 2,
+    "deposit": 1,
+    "transfer": 1,
+    "create_dispute": 3,
+    "juror": 3,
+    "mint_nft": 2,
+}


*** /dev/null
--- a/weall_node/weall_runtime/content.py
@@
+import time
+from collections import defaultdict
+
+
+class Content:
+    """
+    Holds local social graph & content state used by the executor:
+    - users, profiles, posts, comments, messages, groups
+    - counters for posts/comments
+    NOTE: PoH checks are performed by the executor before invoking these.
+    """
+
+    def __init__(self):
+        self.users = {}          # user_id -> {poh_level, reputation, friends, groups}
+        self.profiles = {}       # user_id -> {bio, avatar_cid, created}
+        self.posts = {}          # post_id -> {...}
+        self.comments = {}       # comment_id -> {...}
+        self.messages = defaultdict(list)  # recipient -> list[ message ]
+        self.groups = {}         # group_name -> [member_ids]
+
+        self.next_post_id = 1
+        self.next_comment_id = 1
+
+    # -----------------------------
+    # Users / Profiles
+    # -----------------------------
+    def register_user(self, user_id, poh_level=1, profile=None):
+        if user_id in self.users:
+            return {"ok": False, "error": "user_already_exists"}
+        self.users[user_id] = {
+            "poh_level": poh_level,
+            "reputation": 0,
+            "friends": [],
+            "groups": [],
+        }
+        self.profiles[user_id] = profile or {
+            "bio": "",
+            "avatar_cid": None,
+            "created": time.time(),
+        }
+        return {"ok": True}
+
+    def update_profile(self, user_id, bio=None, avatar_cid=None):
+        prof = self.profiles.get(user_id)
+        if not prof:
+            return {"ok": False, "error": "profile_not_found"}
+        if bio is not None:
+            prof["bio"] = bio
+        if avatar_cid is not None:
+            prof["avatar_cid"] = avatar_cid
+        return {"ok": True}
+
+    def delete_profile(self, user_id):
+        if user_id not in self.profiles:
+            return {"ok": False, "error": "profile_not_found"}
+        del self.profiles[user_id]
+        return {"ok": True}
+
+    # -----------------------------
+    # Social graph
+    # -----------------------------
+    def add_friend(self, user_id, friend_id):
+        if user_id not in self.users or friend_id not in self.users:
+            return {"ok": False, "error": "user_not_registered"}
+        if friend_id not in self.users[user_id]["friends"]:
+            self.users[user_id]["friends"].append(friend_id)
+        return {"ok": True}
+
+    def create_group(self, user_id, group_name, members=None):
+        if user_id not in self.users:
+            return {"ok": False, "error": "user_not_registered"}
+        if group_name in self.groups:
+            return {"ok": False, "error": "group_already_exists"}
+        members = members or [user_id]
+        self.groups[group_name] = members
+        for m in members:
+            self.users[m]["groups"].append(group_name)
+        return {"ok": True}
+
+    # -----------------------------
+    # Posts / Comments
+    # -----------------------------
+    def create_post(self, user_id, content, tags=None, groups=None):
+        pid = self.next_post_id
+        self.next_post_id += 1
+        self.posts[pid] = {
+            "post_id": pid,
+            "user": user_id,
+            "content": content,
+            "tags": tags or [],
+            "groups": groups or [],
+            "comments": [],
+            "likes": 0,
+            "timestamp": time.time(),
+        }
+        return {"ok": True, "post_id": pid}
+
+    def edit_post(self, user_id, post_id, new_content):
+        post = self.posts.get(post_id)
+        if not post or post["user"] != user_id:
+            return {"ok": False, "error": "unauthorized_or_post_missing"}
+        post["content"] = new_content
+        return {"ok": True}
+
+    def delete_post(self, user_id, post_id):
+        post = self.posts.get(post_id)
+        if not post or post["user"] != user_id:
+            return {"ok": False, "error": "unauthorized_or_post_missing"}
+        del self.posts[post_id]
+        return {"ok": True}
+
+    def create_comment(self, user_id, post_id, content, tags=None):
+        if post_id not in self.posts:
+            return {"ok": False, "error": "post_not_found"}
+        cid = self.next_comment_id
+        self.next_comment_id += 1
+        self.comments[cid] = {
+            "comment_id": cid,
+            "user": user_id,
+            "post_id": post_id,
+            "content": content,
+            "tags": tags or [],
+        }
+        self.posts[post_id]["comments"].append(cid)
+        return {"ok": True, "comment_id": cid}
+
+    def delete_comment(self, user_id, comment_id):
+        comment = self.comments.get(comment_id)
+        if not comment or comment["user"] != user_id:
+            return {"ok": False, "error": "unauthorized_or_comment_missing"}
+        post_id = comment["post_id"]
+        if post_id in self.posts:
+            self.posts[post_id]["comments"].remove(comment_id)
+        del self.comments[comment_id]
+        return {"ok": True}
+
+    def like_post(self, user_id, post_id):
+        post = self.posts.get(post_id)
+        if not post:
+            return {"ok": False, "error": "post_not_found"}
+        post["likes"] += 1
+        return {"ok": True}
+
+    # -----------------------------
+    # Messaging
+    # -----------------------------
+    def send_message(self, sender, recipient, content):
+        if sender not in self.users or recipient not in self.users:
+            return {"ok": False, "error": "user_not_registered"}
+        self.messages[recipient].append({
+            "from": sender,
+            "content": content,
+            "timestamp": time.time(),
+        })
+        return {"ok": True}


*** /dev/null
--- a/weall_node/weall_runtime/disputes.py
@@
+from collections import defaultdict
+from ..executor_globals import GLOBAL_PARAMS
+
+
+class Disputes:
+    """
+    Manages disputes & juror votes. Enforces:
+    - One active dispute per (target_type, target_id)
+    - Juror reputation reward/slash vs winning option
+    - Content/profile deletions + author/profile slashing on 'remove'
+    """
+    def __init__(self, content_module):
+        self.content = content_module
+        self.disputes = {}   # id -> dispute dict
+        self.next_dispute_id = 1
+        self.active_by_target = set()  # {(type, id)} for disputes with status 'open'
+
+    # -----------------------------
+    # Creation
+    # -----------------------------
+    def create_dispute(self, reporter_id, target_type, target_id, description):
+        key = (target_type, target_id)
+        if key in self.active_by_target:
+            return {"ok": False, "error": "dispute_exists_for_target"}
+        did = self.next_dispute_id
+        self.next_dispute_id += 1
+        self.disputes[did] = {
+            "dispute_id": did,
+            "reporter": reporter_id,
+            "target_type": target_type,
+            "target_id": target_id,
+            "description": description,
+            "votes": {},
+            "status": "open",
+        }
+        self.active_by_target.add(key)
+        # Reporter bonus handled by executor (reputation), if desired.
+        return {"ok": True, "dispute_id": did}
+
+    # -----------------------------
+    # Voting & Finalization
+    # -----------------------------
+    def juror_vote(self, juror_id, dispute_id, vote_option, quorum):
+        dispute = self.disputes.get(dispute_id)
+        if not dispute:
+            return {"ok": False, "error": "dispute_not_found"}
+        if dispute["status"] != "open":
+            return {"ok": False, "error": "dispute_closed"}
+        if juror_id in dispute["votes"]:
+            return {"ok": False, "error": "already_voted"}
+        dispute["votes"][juror_id] = vote_option
+        if len(dispute["votes"]) >= quorum:
+            self._finalize(dispute)
+        return {"ok": True, "votes": dispute["votes"], "status": dispute["status"]}
+
+    def _finalize(self, dispute):
+        counts = defaultdict(int)
+        for v in dispute["votes"].values():
+            counts[v] += 1
+        winner = max(counts, key=counts.get)
+        dispute["status"] = f"resolved:{winner}"
+
+        # Reward/Slash jurors via content.users reputation
+        for juror_id, vote in dispute["votes"].items():
+            u = self.content.users.get(juror_id)
+            if not u:
+                continue
+            if vote == winner:
+                u["reputation"] += GLOBAL_PARAMS["juror_reward"]
+            else:
+                u["reputation"] = max(0, u["reputation"] - GLOBAL_PARAMS["juror_slash"])
+
+        # Apply outcome effects
+        if winner == "remove":
+            self._apply_removal(dispute["target_type"], dispute["target_id"])
+
+        # Free the target slot
+        self.active_by_target.discard((dispute["target_type"], dispute["target_id"]))
+
+    def _apply_removal(self, target_type, target_id):
+        if target_type == "post":
+            post = self.content.posts.get(target_id)
+            if post:
+                author = post["user"]
+                self.content.posts.pop(target_id, None)
+                user = self.content.users.get(author)
+                if user:
+                    user["reputation"] = max(0, user["reputation"] - GLOBAL_PARAMS["author_slash"])
+        elif target_type == "comment":
+            comment = self.content.comments.get(target_id)
+            if comment:
+                author = comment["user"]
+                pid = comment["post_id"]
+                if pid in self.content.posts:
+                    self.content.posts[pid]["comments"] = [c for c in self.content.posts[pid]["comments"] if c != target_id]
+                self.content.comments.pop(target_id, None)
+                user = self.content.users.get(author)
+                if user:
+                    user["reputation"] = max(0, user["reputation"] - GLOBAL_PARAMS["author_slash"])
+        elif target_type == "profile":
+            if target_id in self.content.profiles:
+                self.content.profiles.pop(target_id, None)
+            user = self.content.users.get(target_id)
+            if user:
+                user["reputation"] = max(0, user["reputation"] - GLOBAL_PARAMS["profile_slash"])
+
+    # -----------------------------
+    # Report helpers
+    # -----------------------------
+    def report_post(self, reporter_id, post_id, description):
+        return self.create_dispute(reporter_id, "post", post_id, description)
+
+    def report_comment(self, reporter_id, comment_id, description):
+        return self.create_dispute(reporter_id, "comment", comment_id, description)
+
+    def report_profile(self, reporter_id, target_user, description):
+        return self.create_dispute(reporter_id, "profile", target_user, description)


*** a/weall_node/weall_runtime/ledger.py
--- b/weall_node/weall_runtime/ledger.py
@@
-import json
+import json
 import threading
 import hashlib
+from collections import defaultdict
 from ..app_state.ledger import LedgerState as WeCoinLedger
