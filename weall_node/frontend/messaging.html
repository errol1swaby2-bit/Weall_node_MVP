<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WeAll — Encrypted Messaging</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Global app styles -->
  <link rel="stylesheet" href="/frontend/style.css">

  <style>
    body {
      margin: 0;
      padding: 0;
      background: #020617;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
        "Segoe UI", sans-serif;
    }

    .msg-shell {
      max-width: 960px;
      margin: 0 auto;
      padding: 1.5rem 1.25rem 3rem;
    }

    .msg-header {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    @media (min-width: 768px) {
      .msg-header {
        flex-direction: row;
        justify-content: space-between;
        align-items: baseline;
      }
    }

    .msg-title {
      font-size: 1.35rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: #f9fafb;
    }

    .msg-subtitle {
      font-size: 0.85rem;
      color: #9ca3af;
      max-width: 420px;
    }

    .signed-in-banner {
      font-size: 0.78rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: #9ca3af;
      text-align: right;
    }

    .signed-in-banner strong {
      font-weight: 600;
    }

    .msg-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1.6fr);
      gap: 1.25rem;
    }

    @media (max-width: 880px) {
      .msg-grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.06), transparent 55%),
                  radial-gradient(circle at bottom right, rgba(168, 85, 247, 0.07), transparent 55%),
                  rgba(15, 23, 42, 0.96);
      border-radius: 0.9rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 1rem 1rem 1.2rem;
      box-shadow:
        0 18px 45px rgba(15, 23, 42, 0.85),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(12px);
    }

    .card h3 {
      margin: 0 0 0.35rem;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #22c55e;
    }

    .card-note {
      font-size: 0.78rem;
      color: #9ca3af;
      margin-bottom: 0.6rem;
    }

    label {
      display: block;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #9ca3af;
      margin-top: 0.4rem;
    }

    input, textarea {
      width: 100%;
      margin-top: 0.25rem;
      border-radius: 0.7rem;
      padding: 0.5rem 0.7rem;
      border: 1px solid rgba(51, 65, 85, 0.9);
      background: rgba(15, 23, 42, 0.95);
      color: #e5e7eb;
      font-size: 0.9rem;
      outline: none;
    }

    input:focus,
    textarea:focus {
      border-color: #22c55e;
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.6);
    }

    textarea {
      min-height: 120px;
      resize: vertical;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      padding: 0.45rem 0.9rem;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.96);
      color: #e5e7eb;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      margin-top: 0.6rem;
    }

    .btn-primary {
      border-color: rgba(34, 197, 94, 0.9);
      background: radial-gradient(circle at top left,
                 rgba(34, 197, 94, 0.4), rgba(15, 23, 42, 0.96));
      color: #ecfeff;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .msg-status {
      margin-top: 0.4rem;
      font-size: 0.78rem;
      color: #9ca3af;
    }

    .scroll-list {
      max-height: 260px;
      overflow-y: auto;
      margin-top: 0.4rem;
      border-radius: 0.7rem;
      border: 1px solid rgba(30, 41, 59, 0.9);
      background: rgba(15, 23, 42, 0.96);
      padding: 0.6rem;
      font-size: 0.86rem;
    }

    .message {
      border-bottom: 1px solid rgba(30, 41, 59, 0.85);
      padding: 0.45rem 0;
    }

    .message:last-child {
      border-bottom: none;
    }

    .message strong {
      color: #22c55e;
    }

    .message small {
      display: inline-block;
      margin-top: 0.15rem;
      font-size: 0.72rem;
      color: #6b7280;
    }

    footer.weall-footer {
      border-top: 1px solid rgba(31, 41, 55, 0.9);
      padding: 0.75rem 1.25rem 1.25rem;
      margin-top: 2rem;
      font-size: 0.78rem;
      color: #6b7280;
      text-align: center;
    }

    footer.weall-footer a {
      color: #9ca3af;
      text-decoration: none;
    }

    footer.weall-footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div class="msg-shell">
    <header class="msg-header">
      <div>
        <h1 class="msg-title">Encrypted Messaging</h1>
        <p class="msg-subtitle">
          Simple, server-routed messages between WeAll IDs. Content can be
          plaintext or client-side encrypted; keys stay on your device.
        </p>
      </div>

      <p id="signedIn" class="signed-in-banner">
        Loading session…
      </p>
    </header>

    <main class="msg-main">
      <section class="msg-grid">
        <!-- Left column: compose + key tools -->
        <div>
          <div class="card">
            <h3>Compose message</h3>
            <p class="card-note">
              Use a WeAll handle or messaging ID for the recipient. Messages
              are stored locally on the network and synced via P2P.
            </p>

            <label for="toUser">Recipient</label>
            <input
              id="toUser"
              type="text"
              placeholder="@handle or messaging ID"
              autocomplete="off"
            />

            <label for="messageBody">Message</label>
            <textarea
              id="messageBody"
              placeholder="Type your message here…"
            ></textarea>

            <button class="btn btn-primary" id="btnSend">
              Send message
            </button>
            <div class="msg-status" id="sendMsg"></div>
          </div>

          <div class="card">
            <h3>Export keys</h3>
            <p class="card-note">
              This downloads your locally stored messaging keys as a JSON file.
              Keep it safe; anyone with this file can read your encrypted
              messages.
            </p>
            <button class="btn" id="btnExportKeys">
              Download keys backup
            </button>
            <div class="msg-status" id="keyMsg">
              Keys are generated and stored on-device elsewhere in the app.
            </div>
          </div>
        </div>

        <!-- Right column: inbox + sent -->
        <div>
          <div class="card">
            <h3>Inbox</h3>
            <div class="scroll-list" id="inbox"></div>
            <div class="msg-status" id="inboxMsg"></div>
          </div>

          <div class="card">
            <h3>Sent</h3>
            <div class="scroll-list" id="sent"></div>
            <div class="msg-status" id="sentMsg"></div>
          </div>
        </div>
      </section>
    </main>

    <footer class="weall-footer">
      <span>© <span id="footer-year">2024</span> WeAll</span>
      &nbsp;•&nbsp;<a href="/frontend/privacy.html">Privacy</a>
      &nbsp;•&nbsp;<a href="/frontend/terms.html">Terms</a>
    </footer>
  </div>

  <!-- Canonical script stack -->
  <script src="/frontend/env.js"></script>
  <script src="/frontend/auth.js"></script>
  <script src="/frontend/session.js"></script>
  <script src="/frontend/nav.js"></script>
  <script src="/frontend/footer.js"></script>

  <script>
    function escapeHtml(str) {
      if (str === null || str === undefined) return "";
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    async function fetchJson(url, opts) {
      const res = await fetch(url, opts || {});
      let data = null;
      try {
        data = await res.json();
      } catch {
        // ignore parse error here; we'll still show status
      }
      if (!res.ok) {
        const msg =
          (data && (data.detail || data.error)) ||
          "Request failed " + res.status;
        throw new Error(msg);
      }
      return data;
    }

    function buildRoleBanner(userId, roles, nodeMeta) {
      const parts = [];

      const tier = (roles && (roles.poh_tier ?? roles.pohTier)) || 0;
      if (tier > 0) {
        parts.push("PoH Tier " + tier);
      } else {
        parts.push("Unverified");
      }

      const flags = (roles && roles.flags) || {};
      const caps = (roles && roles.capabilities) || [];

      const tags = [];
      if (flags.wants_creator || caps.includes("earn_creator_rewards")) {
        tags.push("Creator");
      }
      if (flags.wants_juror || caps.includes("serve_juror_panel")) {
        tags.push("Juror");
      }
      if (flags.wants_validator || caps.includes("validator_duties")) {
        tags.push("Validator");
      }
      if (flags.wants_operator || caps.includes("operator_duties")) {
        tags.push("Operator");
      }
      if (flags.wants_emissary || caps.includes("act_as_emissary")) {
        tags.push("Emissary");
      }

      if (tags.length) {
        parts.push(tags.join(" · "));
      }

      const nodeKind = (nodeMeta && nodeMeta.node_kind) || "public_gateway";
      if (nodeKind === "validator_node") {
        parts.push("Validator node");
      } else if (nodeKind === "private_node") {
        parts.push("Private node");
      } else {
        parts.push("Gateway node");
      }

      return "Signed in as " + userId + " · " + parts.join(" · ");
    }

    async function refreshInbox(messagingUserId) {
      const box = document.getElementById("inbox");
      const msg = document.getElementById("inboxMsg");
      if (!box || !msg) return;

      box.innerHTML = "Loading…";
      msg.textContent = "";

      try {
        const data = await fetchJson(
          "/messaging/inbox/" + encodeURIComponent(messagingUserId)
        );
        if (!Array.isArray(data) || data.length === 0) {
          box.textContent = "No messages.";
          return;
        }

        box.innerHTML = data
          .map((m) => {
            const from = escapeHtml(m.sender || "");
            const content = escapeHtml(m.content || m.body || "");
            const ts = (m.created_at || m.timestamp || 0) * 1000;
            const when = ts ? new Date(ts).toLocaleString() : "–";
            return `
              <div class="message">
                <strong>From:</strong> ${from}<br>
                <p>${content}</p>
                <small>${when}</small>
              </div>
            `;
          })
          .join("");
      } catch (err) {
        console.error("Inbox error:", err);
        msg.textContent = "⚠️ " + (err.message || "Failed to load inbox");
      }
    }

    async function refreshSent(messagingUserId) {
      const box = document.getElementById("sent");
      const msg = document.getElementById("sentMsg");
      if (!box || !msg) return;

      box.innerHTML = "Loading…";
      msg.textContent = "";

      try {
        const data = await fetchJson(
          "/messaging/sent/" + encodeURIComponent(messagingUserId)
        );
        if (!Array.isArray(data) || data.length === 0) {
          box.textContent = "No sent messages.";
          return;
        }

        box.innerHTML = data
          .map((m) => {
            const to = escapeHtml(m.recipient || "");
            const content = escapeHtml(m.content || m.body || "");
            const ts = (m.created_at || m.timestamp || 0) * 1000;
            const when = ts ? new Date(ts).toLocaleString() : "–";
            return `
              <div class="message">
                <strong>To:</strong> ${to}<br>
                <p>${content}</p>
                <small>${when}</small>
              </div>
            `;
          })
          .join("");
      } catch (err) {
        console.error("Sent error:", err);
        msg.textContent = "⚠️ " + (err.message || "Failed to load sent");
      }
    }

    function wireExportKeys() {
      const btn = document.getElementById("btnExportKeys");
      const msg = document.getElementById("keyMsg");
      if (!btn || !msg) return;

      btn.addEventListener("click", () => {
        try {
          const keys = localStorage.getItem("weall_keys");
          if (!keys) {
            alert("No messaging keys stored locally.");
            return;
          }
          const blob = new Blob([keys], { type: "application/json" });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "weall_keys_backup.json";
          a.click();
          msg.textContent = "✅ Keys exported to file.";
        } catch (e) {
          console.error("Export keys error:", e);
          msg.textContent = "⚠️ Failed to export keys.";
        }
      });
    }

    async function sendMessage(messagingUserId) {
      const toEl = document.getElementById("toUser");
      const bodyEl = document.getElementById("messageBody");
      const msg = document.getElementById("sendMsg");
      if (!toEl || !bodyEl || !msg) return;

      const recipient = toEl.value.trim();
      const body = bodyEl.value.trim();
      msg.textContent = "";

      if (!recipient || !body) {
        msg.textContent = "Enter both recipient and message.";
        return;
      }

      try {
        await fetchJson("/messaging/send", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            sender: messagingUserId,
            recipient,
            content: body,
          }),
        });

        msg.textContent = "✅ Message sent.";
        bodyEl.value = "";
        await refreshSent(messagingUserId);
      } catch (err) {
        console.error("Send error:", err);
        msg.textContent = "⚠️ " + (err.message || "Failed to send message");
      }
    }

    async function hydrateMessagingPage() {
      const bannerEl = document.getElementById("signedIn");

      // 1) Auth guard: require at least PoH Tier 1 to use messaging
      const ok = await weallAuth.require({
        minTier: 1,
        redirectToLogin: "/frontend/login.html",
      });
      if (!ok) {
        if (bannerEl) bannerEl.textContent = "Not signed in";
        return;
      }

      // 2) Load auth session to get user_id
      let sess = null;
      try {
        sess = await weallAuth.getSession();
      } catch (e) {
        console.error("getSession failed:", e);
      }
      const userId =
        (sess && sess.user_id) ||
        (weallAuth.getAccount && weallAuth.getAccount()) ||
        "";

      if (!userId) {
        if (bannerEl) bannerEl.textContent = "Not signed in";
        return;
      }

      // 3) Fetch roles + node meta for banner
      const [roles, nodeMeta] = await Promise.all([
        fetchJson("/roles/effective/me", {
          headers: { "X-WeAll-User": userId },
        }),
        fetchJson("/node/meta"),
      ]);

      if (bannerEl) {
        bannerEl.textContent = buildRoleBanner(userId, roles, nodeMeta);
      }

      // 4) Derive messaging identity from local keys, with fallback to userId
      let messagingUserId = userId;
      try {
        const parsed = JSON.parse(localStorage.getItem("weall_keys") || "{}");
        if (parsed && parsed.public) {
          messagingUserId = String(parsed.public);
        }
      } catch (e) {
        console.warn("Failed to parse weall_keys:", e);
      }
      window.weallMessagingUserId = messagingUserId;

      // 5) Wire buttons and initial load
      wireExportKeys();

      const sendBtn = document.getElementById("btnSend");
      if (sendBtn) {
        sendBtn.addEventListener("click", () => {
          sendMessage(messagingUserId);
        });
      }

      await refreshInbox(messagingUserId);
      await refreshSent(messagingUserId);
    }

    document.addEventListener("DOMContentLoaded", () => {
      hydrateMessagingPage().catch((err) => {
        console.error("Failed to hydrate messaging page:", err);
        const bannerEl = document.getElementById("signedIn");
        if (bannerEl) {
          bannerEl.textContent = "Error loading session";
        }
      });
    });
  </script>
</body>
</html>
