"""
WeAll Node — Unified FastAPI Interface
--------------------------------------
• Serves frontend HTML/JS under /frontendtendtend/
• Exposes all backend API modules
• Provides all routes called by the web client
• Production hardening: CORS (config), request IDs, security headers, /readyz,
  optional Prometheus metrics at /metrics/prom while preserving existing /metrics
"""

import os
import uuid
import logging
from weall_node.api import consensus  # <-- add this near your other router imports
# ...
from typing import List, Optional
from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import RedirectResponse, JSONResponse
from pydantic import BaseModel, Field

# Config (expects helpers added earlier)
try:
    from weall_node.config import (
        load_config,
        get_cors_origins,
    )
    _CFG = load_config(repo_root=os.path.dirname(__file__))
    _CORS_ORIGINS = get_cors_origins(_CFG)
except Exception:
    # Safe fallback if config helpers not present yet
    _CFG = {}
    _CORS_ORIGINS = ["http://localhost:5173", "http://127.0.0.1:5173"]

# Optional Prometheus metrics
try:
    from prometheus_fastapi_instrumentator import Instrumentator
    _HAS_PROM = True
except Exception:
    _HAS_PROM = False

from weall_node.weall_executor import WeAllExecutor
from weall_node.api import (
    ledger,
    pinning,
    governance,
    sync,
    messaging,
    poh,
    treasury,
    verification,
    disputes,
    content,
    reputation,
    chain,
    validators,
    operators,
    rewards,
    storage,
    health,
    feed,
    recovery,
)

# ------------------------------------------------------------
# App Setup
# ------------------------------------------------------------
app = FastAPI(title="WeAll Node API", version="1.1")

# CORS: explicit origins; cookie-safe (no "*")
app.add_middleware(
    CORSMiddleware,
    allow_origins=_CORS_ORIGINS,
    allow_credentials=True,
    allow_headers=["*"],
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
)

# Request ID middleware
from starlette.middleware.base import BaseHTTPMiddleware

class RequestIDMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        req_id = request.headers.get("X-Request-ID") or str(uuid.uuid4())
        request.state.request_id = req_id
        response = await call_next(request)
        response.headers["X-Request-ID"] = req_id
        return response

app.add_middleware(RequestIDMiddleware)

# Minimal security headers (your reverse-proxy should also set these)
@app.middleware("http")
async def security_headers(request: Request, call_next):
    resp = await call_next(request)
    resp.headers.setdefault("X-Frame-Options", "DENY")
    resp.headers.setdefault("X-Content-Type-Options", "nosniff")
    resp.headers.setdefault("Referrer-Policy", "no-referrer")
    return resp

# Optional: Prometheus metrics at /metrics/prom (keeps your /metrics route intact)
if _HAS_PROM:
    Instrumentator().instrument(app).expose(app, endpoint="/metrics/prom", include_in_schema=False)

# ------------------------------------------------------------
# Serve Frontend Static Files
# ------------------------------------------------------------
frontend_dir = os.path.join(os.path.dirname(__file__), "frontend")
if os.path.isdir(frontend_dir):
    app.mount("/frontendtendtend", StaticFiles(directory=frontend_dir), name="frontend")
else:
    print(f"[WARN] Frontend directory not found: {frontend_dir}")

# Default route → dashboard
@app.get("/")
def root():
    return RedirectResponse("/frontendtendtend/index.html")

# ------------------------------------------------------------
# Router Mounts (API Modules)
# ------------------------------------------------------------
app.include_router(ledger.router)
app.include_router(pinning.router)
app.include_router(governance.router)
app.include_router(sync.router)
app.include_router(messaging.router)
app.include_router(poh.router)
app.include_router(treasury.router)
app.include_router(verification.router)
app.include_router(disputes.router)
app.include_router(content.router)
app.include_router(reputation.router)
app.include_router(chain.router)
app.include_router(validators.router)
app.include_router(operators.router)
app.include_router(rewards.router)
app.include_router(storage.router)
app.include_router(health.router)
app.include_router(feed.router)
app.include_router(recovery.router)
app.include_router(consensus.router)
# ------------------------------------------------------------
# Executor Runtime
# ------------------------------------------------------------
EXEC = WeAllExecutor()

# ------------------------------------------------------------
# Request Models
# ------------------------------------------------------------
class RegisterRequest(BaseModel):
    user_id: str
    poh_level: int = 1

class FriendRequest(BaseModel):
    user_id: str
    friend_id: str

class MessageRequest(BaseModel):
    from_user: str
    to_user: str
    text: str

class PostRequest(BaseModel):
    user_id: str
    content: str
    tags: Optional[List[str]] = None

class CommentRequest(BaseModel):
    user_id: str
    post_id: int
    content: str
    tags: Optional[List[str]] = None

class DisputeRequest(BaseModel):
    reporter_id: str
    target_type: str = Field(pattern="^(post|comment|profile)$")
    target_id: str
    reason: str

class MintPOHRequest(BaseModel):
    user_id: str
    tier: int

class TransferRequest(BaseModel):
    sender: str
    recipient: str
    amount: float

class TreasuryTransferRequest(BaseModel):
    recipient: str
    amount: float

class PoolSplitRequest(BaseModel):
    validators: float
    jurors: float
    creators: float
    storage: float
    treasury: float

# ------------------------------------------------------------
# Error handling / metrics wrapper
# ------------------------------------------------------------
@app.middleware("http")
async def error_boundary(request: Request, call_next):
    try:
        response = await call_next(request)
        return response
    except HTTPException:
        raise
    except Exception as e:
        # Log with request id if available
        req_id = getattr(request.state, "request_id", "-")
        logging.getLogger("weall.api").exception(f"Unhandled error (req_id={req_id})")
        return JSONResponse({"detail": "internal_error", "request_id": req_id}, status_code=500)

# ------------------------------------------------------------
# System Health / Meta
# ------------------------------------------------------------
@app.get("/health")
def health_endpoint():
    return EXEC.get_health()

@app.get("/readyz")
def readyz():
    # TODO: add concrete checks: DB, IPFS when required, etc.
    return {"ok": True}

@app.get("/metrics")
def metrics():
    # Preserve your existing executor metrics endpoint
    return EXEC.get_metrics()

@app.get("/version")
def version():
    return {"executor": "1.1", "api": app.version}

# ------------------------------------------------------------
# Proof of Humanity (Frontend Hooks)
# ------------------------------------------------------------
@app.get("/poh/status/{user_id}")
def poh_status(user_id: str):
    u = EXEC.state["users"].get(user_id)
    if not u:
        raise HTTPException(404, "user_not_found")
    return {
        "user_id": user_id,
        "poh_level": u.get("poh_level", 0),
        "nfts": u.get("nfts", []),
    }

# ------------------------------------------------------------
# User / Messaging
# ------------------------------------------------------------
@app.post("/register")
def register(req: RegisterRequest):
    return EXEC.register_user(req.user_id, poh_level=req.poh_level)

@app.post("/friend")
def add_friend(req: FriendRequest):
    return EXEC.add_friend(req.user_id, req.friend_id)

@app.post("/message")
def send_message(req: MessageRequest):
    return EXEC.send_message(req.from_user, req.to_user, req.text)

@app.get("/messages/{user_id}")
def read_messages(user_id: str):
    return EXEC.read_messages(user_id)

# ------------------------------------------------------------
# Posts / Comments
# ------------------------------------------------------------
@app.post("/post")
def create_post(req: PostRequest):
    return EXEC.create_post(req.user_id, req.content, req.tags or [])

@app.post("/comment")
def create_comment(req: CommentRequest):
    return EXEC.create_comment(req.user_id, req.post_id, req.content, req.tags or [])

@app.get("/show_posts")
def show_posts():
    return {"ok": True, "posts": EXEC.state.get("posts", {})}

# ------------------------------------------------------------
# Governance
# ------------------------------------------------------------
@app.get("/governance/proposals")
def governance_list():
    gov = getattr(EXEC, "governance", None)
    if not gov:
        return {"ok": False, "error": "governance_unavailable"}
    proposals = getattr(gov, "proposals", [])
    return {str(i): p for i, p in enumerate(proposals)}

@app.post("/governance/vote")
def governance_vote(data: dict):
    user = data.get("user")
    pid = data.get("proposal_id")
    vote = data.get("vote")
    return EXEC.cast_vote(user, pid, vote)

@app.post("/governance/new")
def governance_new(data: dict):
    title = data.get("title")
    desc = data.get("description")
    amount = data.get("amount")
    return EXEC.create_proposal(title, desc, amount)

# ------------------------------------------------------------
# Ledger / Treasury
# ------------------------------------------------------------
@app.get("/ledger/balance/{user_id}")
def balance(user_id: str):
    return {"ok": True, "user_id": user_id, "balance": EXEC.ledger.balance(user_id)}

@app.post("/ledger/transfer")
def transfer(req: TransferRequest):
    return EXEC.transfer(req.sender, req.recipient, req.amount)

@app.post("/ledger/treasury/transfer")
def treasury_transfer(req: TreasuryTransferRequest):
    return EXEC.treasury_transfer(req.recipient, req.amount)

# ------------------------------------------------------------
# Disputes
# ------------------------------------------------------------
@app.post("/dispute")
def create_dispute(req: DisputeRequest):
    target_id = (
        int(req.target_id)
        if req.target_type in ("post", "comment") and req.target_id.isdigit()
        else req.target_id
    )
    return EXEC.create_dispute(req.reporter_id, req.target_type, target_id, req.reason)

# ------------------------------------------------------------
# NFTs (PoH & custom)
# ------------------------------------------------------------
@app.post("/mint_poh")
def mint_poh(req: MintPOHRequest):
    return EXEC.mint_poh_nft(req.user_id, req.tier)

# ------------------------------------------------------------
# P2P / Blocks
# ------------------------------------------------------------
@app.get("/p2p/peers")
def p2p_peers():
    return {"node_id": EXEC.node_id, "peers": EXEC.p2p.get_peer_list()}

@app.post("/p2p/add_peer/{peer_id}")
def p2p_add_peer(peer_id: str):
    EXEC.p2p.add_peer(peer_id)
    return {"ok": True, "peers": EXEC.p2p.get_peer_list()}

@app.post("/block/new/{producer_id}")
def new_block(producer_id: str):
    return EXEC.on_new_block(producer_id)

@app.post("/block/sim/{n}")
def simulate_blocks(n: int):
    EXEC.simulate_blocks(n)
    return {"ok": True, "height": EXEC.current_block_height}

# ------------------------------------------------------------
# Admin Config
# ------------------------------------------------------------
@app.post("/admin/pool_split")
def set_pool_split(req: PoolSplitRequest):
    split = req.dict()
    if abs(sum(split.values()) - 1.0) > 1e-6:
        raise HTTPException(400, "split_must_sum_to_1")
    EXEC.set_pool_split(split)
    return {"ok": True, "pool_split": EXEC.pool_split}

@app.post("/admin/blocks_per_epoch/{bpe}")
def set_blocks_per_epoch(bpe: int):
    EXEC.set_blocks_per_epoch(bpe)
    return {"ok": True, "blocks_per_epoch": EXEC.blocks_per_epoch}

@app.post("/admin/halving_interval/{epochs}")
def set_halving_interval(epochs: int):
    EXEC.set_halving_interval_epochs(epochs)
    return {"ok": True, "halving_interval_epochs": EXEC.halving_interval_epochs}

@app.post("/admin/save")
def admin_save():
    return EXEC.save_state()

@app.post("/admin/load")
def admin_load():
    return EXEC.load_state()
